<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-06-22 pon 22:12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Structured Bindings</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Łukasz Maciejewski" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Structured Bindings</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org38f7c0c">1. What are structured bindings</a></li>
<li><a href="#org643470b">2. Names for stuff</a></li>
<li><a href="#orgf66c220">3. Example 1 - destructuring an array</a></li>
<li><a href="#org62db640">4. Example 2 - binding to data members of a struct</a></li>
<li><a href="#org66b08b3">5. Example 3 - destructuring a tuple</a></li>
<li><a href="#orge2a0873">6. It&rsquo;s C++ - things are not that simple</a></li>
<li><a href="#orge584332">7. Example 4 - binding to evaluation results</a></li>
<li><a href="#org0ed0923">8. Key takeaways</a></li>
<li><a href="#org5c0d7fc">9. Example 5 - <code>std::array</code> ??!!</a></li>
<li><a href="#orge2f30cc">10. How is the destructuring algorithm chosen?</a></li>
<li><a href="#org1bb2a3a">11. Adding tuple-like interface for custom types</a></li>
<li><a href="#orgf5b83a6">12. Example 6 - binding for user-defined type</a></li>
<li><a href="#org0f12e8d">13. Example 6 - continued</a></li>
</ul>
</div>
</div>


<div id="outline-container-org38f7c0c" class="outline-2">
<h2 id="org38f7c0c"><span class="section-number-2">1</span> What are structured bindings</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">[</span>x_1, <span style="color: #405A61;">/*</span><span style="color: #405A61;">...</span><span style="color: #405A61;">*/</span>, x_n<span style="color: #268bd2;">]</span> = expression;
</pre>
</div>

<div class="NOTES">
<p>
Structured bindings are a way of accessing and conveniently referencing
components of a larger entity, something that has an internal structure - hence the
<i>structured</i> part. In C++, those larger entities are arrays, structs/classes or
tuples. Instead of going through detailed, dry definitions, let&rsquo;s look at some
examples. But first let&rsquo;s name the parts involved in creating a structured
bindings.
</p>

</div>
</div>
</div>

<div id="outline-container-org643470b" class="outline-2">
<h2 id="org643470b"><span class="section-number-2">2</span> Names for stuff</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-c++">cv-<span style="color: #859900; font-weight: bold;">auto</span> ref-spec <span style="color: #268bd2;">[</span>identifier-list<span style="color: #268bd2;">]</span> = expression;

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #b58900;">E</span> = <span style="color: #859900; font-weight: bold;">decltype</span><span style="color: #268bd2;">(</span>expression<span style="color: #268bd2;">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>structured bindings - the name of the feature in C++</li>
<li>destructuring - general name for accessing the components of a structured entity</li>
</ul>

<div class="NOTES">
<ul class="org-ul">
<li><code>cv-auto</code> is the mandatory <code>auto</code> keyword, possibly qualified with <code>const</code>, but curiously not with <code>volatile</code> (since C++20). It can also be qualified with storage duration specifier - <code>static</code> or <code>thread_local</code>,</li>
<li><code>ref-spec</code> can be either nothing, an l-value reference (<code>&amp;</code>), or an r-value reference (<code>&amp;&amp;</code>),</li>
<li><code>identifier-list</code> is a list of identifiers that get introduced into the surrounding context by the structuded binding declaration,</li>
<li><code>expression</code> is the expression we&rsquo;re binding to,</li>
<li><code>E</code> is the type of the <code>expression</code>.</li>
</ul>

</div>
</div>
</div>

<div id="outline-container-orgf66c220" class="outline-2">
<h2 id="orgf66c220"><span class="section-number-2">3</span> Example 1 - destructuring an array</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">int</span> <span style="color: #839496;">arr</span><span style="color: #268bd2;">[</span><span style="color: #d33682; font-weight: bold;">2</span><span style="color: #268bd2;">]</span> = <span style="color: #268bd2;">{</span> <span style="color: #405A61;">/*</span><span style="color: #405A61;">init</span><span style="color: #405A61;">*/</span> <span style="color: #268bd2;">}</span>;
<span style="color: #859900; font-weight: bold;">auto</span>&amp; <span style="color: #268bd2;">[</span><span style="color: #d33682; font-weight: bold;">x_0</span>, <span style="color: #d33682; font-weight: bold;">x_1</span><span style="color: #268bd2;">]</span> = arr;
<span style="color: #405A61;">// </span><span style="color: #405A61;">eqivalent to</span>
<span style="color: #b58900;">int</span>&amp; <span style="color: #839496;">x_0</span> = arr<span style="color: #268bd2;">[</span><span style="color: #d33682; font-weight: bold;">0</span><span style="color: #268bd2;">]</span>;
<span style="color: #b58900;">int</span>&amp; <span style="color: #839496;">x_1</span> = arr<span style="color: #268bd2;">[</span><span style="color: #d33682; font-weight: bold;">1</span><span style="color: #268bd2;">]</span>;
</pre>
</div>

<div class="NOTES">
<p>
If you have a built-in array of any type, you can destructure it&rsquo;s elements into named variables.
The number of elements in the identifier list has to match the number of elements of the array.
</p>

</div>
</div>
</div>

<div id="outline-container-org62db640" class="outline-2">
<h2 id="org62db640"><span class="section-number-2">4</span> Example 2 - binding to data members of a struct</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">S</span> <span style="color: #268bd2;">{</span>
  <span style="color: #b58900;">int</span> <span style="color: #839496;">m_1</span>;
  <span style="color: #b58900;">float</span> <span style="color: #839496;">m_2</span>;
  <span style="color: #b58900;">double</span> <span style="color: #839496;">m_3</span>;
<span style="color: #268bd2;">}</span>;

<span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #839496;">s</span> = S<span style="color: #268bd2;">{</span><span style="color: #405A61;">/*</span><span style="color: #405A61;">init</span><span style="color: #405A61;">*/</span><span style="color: #268bd2;">}</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #859900; font-weight: bold;">auto</span>&amp; <span style="color: #268bd2;">[</span><span style="color: #d33682; font-weight: bold;">x</span>, <span style="color: #d33682; font-weight: bold;">y</span>, <span style="color: #d33682; font-weight: bold;">z</span><span style="color: #268bd2;">]</span> = s;
<span style="color: #405A61;">// </span><span style="color: #405A61;">equivalent to</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span>&amp; <span style="color: #839496;">x</span> = s.m_1;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">float</span>&amp; = s.m_2;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">double</span>&amp; = s.m_3;
</pre>
</div>

<div class="NOTES">
<p>
When destructuring an instance of a struct or a class, you need to be able to access all the
data members. If you attempt to destructure an object of a class with private members, your program
fails to compile. Your identifier list has to have the same number of elements as the number of data
members of the struct/class you&rsquo;re destructuring.
</p>

</div>
</div>
</div>

<div id="outline-container-org66b08b3" class="outline-2">
<h2 id="org66b08b3"><span class="section-number-2">5</span> Example 3 - destructuring a tuple</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #d33682; font-weight: bold;">std</span>::<span style="color: #b58900;">tuple</span><span style="color: #268bd2;">&lt;</span><span style="color: #d33682; font-weight: bold;">std</span>::size_t, <span style="color: #b58900;">char</span><span style="color: #268bd2;">&gt;</span> <span style="color: #839496;">t</span><span style="color: #268bd2;">{</span><span style="color: #405A61;">/*</span><span style="color: #405A61;">init</span><span style="color: #405A61;">*/</span><span style="color: #268bd2;">}</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">[</span>v1, v2<span style="color: #268bd2;">]</span> = t;
<span style="color: #405A61;">// </span><span style="color: #405A61;">equivalent to</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #d33682; font-weight: bold;">std</span>::<span style="color: #b58900;">size_t</span> <span style="color: #839496;">v1</span> = <span style="color: #d33682; font-weight: bold;">std</span>::get<span style="color: #268bd2;">&lt;</span><span style="color: #d33682; font-weight: bold;">0</span><span style="color: #268bd2;">&gt;(</span>t<span style="color: #268bd2;">)</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">char</span> <span style="color: #839496;">v2</span> = <span style="color: #d33682; font-weight: bold;">std</span>::get<span style="color: #268bd2;">&lt;</span><span style="color: #d33682; font-weight: bold;">1</span><span style="color: #268bd2;">&gt;(</span>t<span style="color: #268bd2;">)</span>;
</pre>
</div>

<div class="NOTES">
<p>
Destructuring tuple is similiar to destructuring a struct, but the compiler goes through library-defined <code>get</code> function, not the internal compiler magic, to retrieve the values.
</p>

</div>
</div>
</div>

<div id="outline-container-orge2a0873" class="outline-2">
<h2 id="orge2a0873"><span class="section-number-2">6</span> It&rsquo;s C++ - things are not that simple</h2>
<div class="outline-text-2" id="text-6">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #d33682; font-weight: bold;">std</span>::<span style="color: #b58900;">tuple</span><span style="color: #268bd2;">&lt;</span><span style="color: #d33682; font-weight: bold;">std</span>::size_t, <span style="color: #b58900;">char</span><span style="color: #268bd2;">&gt;</span> <span style="color: #839496;">t</span><span style="color: #268bd2;">{</span><span style="color: #405A61;">/*</span><span style="color: #405A61;">init</span><span style="color: #405A61;">*/</span><span style="color: #268bd2;">}</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #859900; font-weight: bold;">auto</span>&amp; <span style="color: #268bd2;">[</span><span style="color: #d33682; font-weight: bold;">v1</span>, <span style="color: #d33682; font-weight: bold;">v2</span><span style="color: #268bd2;">]</span> = t;
<span style="color: #d33682; font-weight: bold;">EXPECT_TRUE</span><span style="color: #268bd2;">(</span><span style="color: #d33682; font-weight: bold;">std</span>::<span style="color: #b58900;">is_reference_v</span><span style="color: #d33682;">&lt;</span><span style="color: #859900; font-weight: bold;">decltype</span><span style="color: #859900;">(</span>v1<span style="color: #859900;">)</span><span style="color: #d33682;">&gt;</span><span style="color: #268bd2;">)</span>; <span style="color: #405A61;">// </span><span style="color: #405A61;">FAIL!!!</span>
</pre>
</div>

<p>
Type of <code>v1</code> is actually <code>const std::size_t</code>!
</p>

<div class="NOTES">
<p>
The way of thinking we&rsquo;ve introduced in the previous examples is useful, but simplified.
As C++ programmers, we should be able to operate on a simplified mental model of
the language just to get things done. At the same time, we need to also be aware
of the nuances that may come up in corner cases or in performace critical parts.
In this case, the situation is a bit nuanced because in a non-garbage-collected
languages we need to concider the lifetimes of the temporaries that may be
created when evaluating the expression we&rsquo;re binding to.
</p>

</div>
</div>
</div>

<div id="outline-container-orge584332" class="outline-2">
<h2 id="orge584332"><span class="section-number-2">7</span> Example 4 - binding to evaluation results</h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">Vector2D</span> <span style="color: #839496;">a</span> = <span style="color: #268bd2;">{</span><span style="color: #405A61;">/*</span><span style="color: #405A61;">init</span><span style="color: #405A61;">*/</span><span style="color: #268bd2;">}</span>;
<span style="color: #b58900;">Vector2D</span> <span style="color: #839496;">b</span> = <span style="color: #268bd2;">{</span><span style="color: #405A61;">/*</span><span style="color: #405A61;">init</span><span style="color: #405A61;">*/</span><span style="color: #268bd2;">}</span>;

<span style="color: #859900; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #268bd2;">[</span><span style="color: #d33682; font-weight: bold;">c1</span>, <span style="color: #d33682; font-weight: bold;">c2</span><span style="color: #268bd2;">]</span> = a + b;
</pre>
</div>

<p>
The result of <code>a + b</code> has to &rsquo;live&rsquo; somewhere.
</p>

<div class="NOTES">
<p>
We omit the detailed definition of the <code>Vector2D</code> class, but hopefully everyone
can imagine what it looks like and specifically how a sane definition of an
<code>operator+</code> would look in this case. The result of evaluating <code>a + b</code> is a
temporary object that will be destroyed at semicolon ending the last line -
unless it gets captured in some variable. For precisely such case, the
structuded binding declaration introduces an implicitly defined, not directly
accessible variable - let&rsquo;s call it <code>e</code> for short. This variable is then
initialized by the expression in the structuded binding and the <code>cv-auto</code> and
<code>ref-spec</code> parts actually refer to that variable, not to the identifiers on the
list. The identifiers are then bound to the relevant parts of <code>e</code> by internal
compiler magic. That&rsquo;s why they&rsquo;re not explicitly reference types.
</p>

</div>
</div>
</div>

<div id="outline-container-org0ed0923" class="outline-2">
<h2 id="org0ed0923"><span class="section-number-2">8</span> Key takeaways</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>You may already have seen this - e.g. in Python; the concept is not C++ specific.</li>
</ul>
<ul class="org-ul">
<li>You can destructure native arrays, tuple-like types, and structs</li>
</ul>
<ul class="org-ul">
<li>The number of elements in the destructured entity needs to be known at compile time.</li>
</ul>
<ul class="org-ul">
<li>The number of identifiers has to exactly match the number of structural components.</li>
</ul>
<ul class="org-ul">
<li>The identifiers have to be unique and there is no special <i>ignore</i> identifier (like &rsquo;_&rsquo; in Python).</li>
</ul>
</div>
</div>

<div id="outline-container-org5c0d7fc" class="outline-2">
<h2 id="org5c0d7fc"><span class="section-number-2">9</span> Example 5 - <code>std::array</code> ??!!</h2>
<div class="outline-text-2" id="text-9">
<p>
So how does this work?
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #d33682; font-weight: bold;">std</span>::<span style="color: #b58900;">array</span><span style="color: #268bd2;">&lt;</span><span style="color: #b58900;">double</span>, <span style="color: #d33682; font-weight: bold;">3</span><span style="color: #268bd2;">&gt;</span> <span style="color: #839496;">a</span> = <span style="color: #268bd2;">{</span><span style="color: #d33682; font-weight: bold;">1.0</span>, <span style="color: #d33682; font-weight: bold;">2.71</span>, <span style="color: #d33682; font-weight: bold;">3.14</span><span style="color: #268bd2;">}</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #859900; font-weight: bold;">auto</span>&amp; <span style="color: #268bd2;">[</span><span style="color: #d33682; font-weight: bold;">one</span>, <span style="color: #d33682; font-weight: bold;">e</span>, <span style="color: #d33682; font-weight: bold;">pi</span><span style="color: #268bd2;">]</span> = a;
</pre>
</div>

<div class="NOTES">
<p>
This code somehow works. The <code>std::array</code> is a regular class, not some compiler
intrinsic type, so there may be a generic mechanism that allows us to teach the
compiler on how to destructure our own types also.
</p>

</div>
</div>
</div>

<div id="outline-container-orge2f30cc" class="outline-2">
<h2 id="orge2f30cc"><span class="section-number-2">10</span> How is the destructuring algorithm chosen?</h2>
<div class="outline-text-2" id="text-10">

<div class="figure">
<p><img src="destructuring_algorithm.png" alt="destructuring_algorithm.png" />
</p>
</div>

<div class="NOTES">
<p>
There are three distinct ways the compiler can destructure an expression for us. If the type is a native array, then destructuring means binding to the elements of the array in sequence. If it is not an array, then the compiler checks if a template specialization of std::tuple<sub>size</sub> is defined for our type. If it is not, then compiler tries to destructure it by accessing data members. If the std::tuple<sub>size</sub> template is specialized for our type though, then compiler starts to further look for the elements it needs to create a binding. Let&rsquo;s now look at what those elements are.
</p>

</div>
</div>
</div>


<div id="outline-container-org1bb2a3a" class="outline-2">
<h2 id="org1bb2a3a"><span class="section-number-2">11</span> Adding tuple-like interface for custom types</h2>
<div class="outline-text-2" id="text-11">
<p>
When <code>E</code> is a user defined type, the following need to exist:
</p>
<ul class="org-ul">
<li><code>std::tuple_size&lt;E&gt;::value</code></li>
<li><code>std::tuple_element&lt;i, E&gt;::type</code></li>
<li>either a <code>E::get&lt;i&gt;()</code> or standalone <code>get&lt;i&gt;(/*const*/ E /*&amp;*/)</code></li>
</ul>

<div class="NOTES">
<p>
The <code>tuple_size::value</code> denotes the number of elements to destructure in our type.
The <code>tuple_element&lt;...&gt;::type</code> provides information about what type is each of the structural elements.
Finally, the <code>get</code> functions are used to obtain the values of each element. Note, that if the standalone <code>get</code> is to be used, it needs to be defined in the same namespace as <code>E</code>, otherwise the compiler will not be able to find it.
</p>

</div>
</div>
</div>

<div id="outline-container-orgf5b83a6" class="outline-2">
<h2 id="orgf5b83a6"><span class="section-number-2">12</span> Example 6 - binding for user-defined type</h2>
<div class="outline-text-2" id="text-12">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #d33682; font-weight: bold;">experiment</span> <span style="color: #268bd2;">{</span>
<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Vector2D</span> <span style="color: #d33682;">{</span>
  <span style="color: #b58900;">double</span> <span style="color: #839496;">x</span>;
  <span style="color: #b58900;">double</span> <span style="color: #839496;">y</span>;
<span style="color: #859900; font-weight: bold;">public</span>:
  <span style="color: #859900; font-weight: bold;">template</span><span style="color: #859900;">&lt;</span><span style="color: #d33682; font-weight: bold;">std</span>::<span style="color: #b58900;">size_t</span> <span style="color: #839496;">idx</span><span style="color: #859900;">&gt;</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">get</span><span style="color: #859900;">()</span>;
<span style="color: #d33682;">}</span>;
<span style="color: #268bd2;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0f12e8d" class="outline-2">
<h2 id="org0f12e8d"><span class="section-number-2">13</span> Example 6 - continued</h2>
<div class="outline-text-2" id="text-13">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #d33682; font-weight: bold;">std</span> <span style="color: #268bd2;">{</span>
<span style="color: #859900; font-weight: bold;">template</span><span style="color: #d33682;">&lt;&gt;</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">tuple_size</span><span style="color: #d33682;">&lt;</span><span style="color: #d33682; font-weight: bold;">experiment</span>::Vector2D<span style="color: #d33682;">&gt;</span>
  : <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #d33682; font-weight: bold;">std</span>::<span style="color: #b58900;">integral_constant</span><span style="color: #d33682;">&lt;</span><span style="color: #d33682; font-weight: bold;">std</span>::size_t, <span style="color: #d33682; font-weight: bold;">2</span><span style="color: #d33682;">&gt;</span> <span style="color: #d33682;">{}</span>;
<span style="color: #859900; font-weight: bold;">template</span><span style="color: #d33682;">&lt;</span><span style="color: #d33682; font-weight: bold;">std</span>::<span style="color: #b58900;">size_t</span> <span style="color: #839496;">idx</span><span style="color: #d33682;">&gt;</span>
<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">tuple_element</span><span style="color: #d33682;">&lt;</span>idx, <span style="color: #d33682; font-weight: bold;">experiment</span>::Vector2D<span style="color: #d33682;">&gt;</span> <span style="color: #d33682;">{</span>
  <span style="color: #859900; font-weight: bold;">using</span> <span style="color: #b58900;">type</span> = <span style="color: #b58900;">double</span>;
<span style="color: #d33682;">}</span>
<span style="color: #268bd2;">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2020-06-18</p>
<p class="author">Author: Łukasz Maciejewski</p>
<p class="date">Created: 2020-06-22 pon 22:12</p>
</div>
</body>
</html>
